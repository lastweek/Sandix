2014/11/28

This days i have tried something about linkers and loaders.
I used to confused about how linker works, also have no
idea about how loaders load a program into memory.

I spend two days searching books introduing link&loader.
Fortunately, i find two books. Also, i find some material
in Apple.com about Mach-O format which is far different from
ELF.

Aha, i find something in /usr/include/marh-o, there are some
headers defines Mach-O format with extremely description.
And the descriptions in those headers are almost the same with
the manuals downloaded from Apple.com.

So, tomorrow i will figure out more things about it. This 
learning step makes me a better understanding about running 
program, operating system, virtual memory and so on.

My future plan is to read more on VMM and OS, you konw,
every programmer should konw how your program is executed.

Here are some commands we can use to manipulate Relocatable
Object File or Executable Object File or Shared Library:
	otool	(which similar to objdump.)
	nm		(list symbol name in Object)
	file	(Figure out file type.)
	size	(print the size of the sections in an object file.)
	ar		(archive)
	as		(assember)
	cpp		(C preprocessor)
	ld		(link objects)
	cond.


2014/11/29

Er...i got more confused about linker&loader&VM

I test two codes, both of them print same address of printf&memset,
so i am asking myself: dose library functions mapped into different process
have the some memory address? Maybe it does as the results, maybe it does not,
need me to figure it out.
(猜测：每个lib载入到内存之后便被OS映射到一快连续的VM。然后每个process动态链接这个lib时，
dynamic linker就把lib的VM地址给了各process，所以各个process看到的printf地址一样。)

lib.a:		memory addr start from 0x00000000
lib.dyliy:	memory addr start depends on each lib.
Still one more question: when loader load libx into memory, where to put libx?
how to map libx to process?

