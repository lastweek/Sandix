#
#	Makefile.build
#	Sub-Building ;)
#

src := $(obj)

PHONY += __build
__build:

obj-y :=
subdir-obj-y :=
subdir-y :=
obj-dirs :=

lib-y :=
lib-target :=

loader-y :=
objcopy-y :=
objdump-y :=

include $(srctree)/scripts/Kbuild.include
include $(srctree)/$(src)/Makefile
include $(srctree)/scripts/Makefile.libb

ifneq ($(strip $(obj-y)),)
builtin-target := $(obj)/built-in.o
endif

ifneq ($(strip $(objcopy-y)),)
objcopy-target := $(patsubst %,%-objcopy,$(objcopy-y))
endif

ifneq ($(strip $(objdump-y)),)
objdump-target := $(patsubst %,%-objdump,$(objdump-y))
endif

ifneq ($(strip $(loader-y)),)
loader-target := $(loader-y)
endif

# Default target
__build: $(builtin-target) $(subdir-y) $(loader-target) \
		 $(objcopy-target) $(objdump-target) $(lib-target)

# If the list is empty, create an empty built-in.o
ifdef builtin-target
quiet_cmd_link_o_target = LD $(SS) $@
      cmd_link_o_target = \
	  					$(if $(strip $(obj-y)),\
	  					$(LD) $(ld_flags) -r -o $@ $(obj-y), \
						rm -f $@; $(AR) rcs$(KBUILD_ARFLAGS) $@)

$(builtin-target): $(obj-y) FORCE
	$(call if_changed,link_o_target)
endif


ifdef loader-target
quiet_cmd_loader = AS $(SS) $@
      cmd_loader = $(CC) $(a_flags) -c -o $@ $<

$(loader-target): $(patsubst %.o,%.S,$(loader-y)) 
	$(call if_changed,loader)
endif


ifdef objcopy-target
quiet_cmd_objcopy = OBJCOPY $(SS) $@
      cmd_objcopy = $(OBJCOPY) $(objcopy_flags) $(patsubst %-objcopy,%,$@) $@

$(objcopy-target): FORCE
	$(call cmd,objcopy)
endif


ifdef objdump-target
quiet_cmd_objdump = OBJDUMP $(SS) $@
      cmd_objdump = $(OBJDUMP) $(objdump_flags) $(patsubst %-objdump,%,$@) >$@

$(objdump-target): FORCE
	$(call cmd,objdump)
endif

ifneq ($(strip $(lib-target)),)
quiet_cmd_link_l_target = AR $(SS) $@
      cmd_link_l_target = rm -f $@; $(AR) rcs$(KBUILD_ARFLAGS) $@ $(lib-y)

$(lib-target): $(lib-y) FORCE
	$(call if_changed,link_l_target)
endif

# Descending into sub-directory
$(sort $(subdir-obj-y)): $(subdir-y) ;
PHONY += $(subdir-y)
$(subdir-y):
	$(Q)$(MAKE) $(BUILD)=$@


# include dependencies
_dep_files := $(filter-out $(subdir-obj-y),$(obj-y))
dep_files  := $(foreach f,$(_dep_files),$(dir $(f)).$(notdir $(f)).d)

ifneq ($(dep_files),)
  -include $(dep_files)
endif




# PART 2
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# After define the rules and prerequisites between those "top" targets,
# it's time to do the real dirty work: COMPILE and LINK SOURCE FILES.
# We have two versions cmd, one for beautiful output, one for work. ;)
# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

# .c --> .o
# ---------------------------------------------------------------------------
#* Target: $(obj)/%.o
#* Depend on: $(src)/%.c
#* Desc: Compile (.c) to (.o)
# ---------------------------------------------------------------------------
# The C file is compiled and updated dependency information is generated.
quiet_cmd_cc_o_c = CC $(SS) $@
      cmd_cc_o_c = $(CC) $(c_flags) -c -o $@ $<

$(obj)/%.o: $(src)/%.c FORCE
	$(call if_changed,cc_o_c)



# .c --> .s
# ---------------------------------------------------------------------------
#* Target: $(obj)/%.s
#* Depend on: $(src)/%.c
#* Desc: Compile (.c) to (.s)
# ---------------------------------------------------------------------------
quiet_cmd_cc_s_c = CC $(SS) $@
      cmd_cc_s_c = $(CC) $(c_flags) -fverbose-asm -S -o $@ $<

$(obj)/%.s: $(src)/%.c FORCE
	$(call if_changed,cc_s_c)



# .c --> .i
# ---------------------------------------------------------------------------
#* Target: $(obj)/%.i
#* Depend on: $(src)/%.c
#* Desc: Compile (.c) to (.i)
# ---------------------------------------------------------------------------
quiet_cmd_cc_i_c = CPP $(SS) $@
      cmd_cc_i_c = $(CPP) $(c_flags) -o $@ $<

$(obj)/%.i: $(src)/%.c FORCE
	$(call if_changed,cc_i_c)



# .S --> .s
# ---------------------------------------------------------------------------
#* Target: $(obj)/%.s
#* Depend on: $(src)/%.S
#* Desc: Compile (.S) to (.s)
# ---------------------------------------------------------------------------
modkern_aflags := $(KBUILD_AFLAGS_KERNEL) $(AFLAGS_KERNEL)

quiet_cmd_as_s_S = CPP $(SS) $@
      cmd_as_s_S = $(CPP) $(a_flags) -o $@ $<

$(obj)/%.s: $(src)/%.S FORCE
	$(call if_changed,as_s_S)



# .S --> .o
# ---------------------------------------------------------------------------
#* Target: $(obj)/%.o
#* Depend on: $(src)/%.S
#* Desc: Compile (.S) to (.o)
# ---------------------------------------------------------------------------
quiet_cmd_as_o_S = AS $(SS) $@
      cmd_as_o_S = $(CC) $(a_flags) -c -o $@ $<

$(obj)/%.o: $(src)/%.S FORCE
	$(call if_changed,as_o_S)


# .lds.S --> .lds
# ---------------------------------------------------------------------------
#* Target: $(obj)/%.lds
#* Depend on: $(src)/%.lds.S
#* Desc: Linker scripts preprocessor (.lds.S -> .lds)
# ---------------------------------------------------------------------------
quiet_cmd_cpp_lds_S = LDS $(SS) $@
      cmd_cpp_lds_S = $(CPP) $(cpp_flags) -P -C -U$(ARCH) \
	                     -D__ASSEMBLY__ -DLINKER_SCRIPT -o $@ $<

$(obj)/%.lds: $(src)/%.lds.S FORCE
	$(call if_changed,cpp_lds_S)



# ---------------------------------------------------------------------------
#* Target: FORCE
#* Depend on:
#* Desc: Add FORCE to force a target to be always rebuilt.
# ---------------------------------------------------------------------------
PHONY += FORCE
FORCE:

# ---------------------------------------------------------------------------
# Declare the contents of the .PHONY variable as phony.  We keep that
# information in a variable se we can use it in if_changed.
# ---------------------------------------------------------------------------
.PHONY: $(PHONY)
