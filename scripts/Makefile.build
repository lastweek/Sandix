#
#	script/Makefile.build - Shopping?
#	
#	Copyright (C) 2015 Yizhou Shan <shanyizhou@ict.ac.cn>
#
#	This program is free software; you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation; either version 2 of the License, or
#	(at your option) any later version.
#
#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License along
#	with this program; if not, write to the Free Software Foundation, Inc.,
#	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

src := $(obj)

ifndef obj
$(warning Kbuild: Makefile.build is included improperly)
endif

PHONY += __BUILD
__BUILD:

# Init all relevant variables used in kbuild files so
# 1) they have correct type
# 2) they do not inherit any value from the environment
obj-y :=
lib-y :=
subdir-y :=
asflags-y  :=
ccflags-y  :=
cppflags-y :=
ldflags-y  :=
always :=
targets :=

subdir-asflags-y :=
subdir-ccflags-y :=

loader-y :=
objcopy-y :=
objdump-y :=

include $(srctree)/scripts/Kbuild.include
include $(srctree)/$(src)/Makefile
include $(srctree)/scripts/Makefile.lib

ifneq ($(hostprogs-y),)
include $(srctree)/scripts/Makefile.host
endif

# ------------------------------------------------------------------------
# Figure out what $(srctree)/$(src)/Makefile want.
# ------------------------------------------------------------------------

ifneq ($(strip $(lib-y)),)
lib-target := $(obj)/lib.a
endif

ifneq ($(strip $(obj-y) $(lib-target)),)
builtin-target := $(obj)/built-in.o
endif

ifneq ($(strip $(objcopy-y)),)
objcopy-target := $(patsubst %.o,%.bin,$(objcopy-y))
endif

ifneq ($(strip $(objdump-y)),)
objdump-target := $(patsubst %,%.objdump,$(objdump-y))
endif

ifneq ($(strip $(loader-y)),)
loader-target := $(loader-y)
endif

# Default target depends on everything
# ------------------------------------------------------------------------
__BUILD: $(builtin-target) $(lib-target) $(subdir-y)		\
	 $(loader-target) $(objcopy-target) $(objdump-target)	\
	 $(extra-y) $(always)
	@:

targets += $(extra-y) $(always)

# ------------------------------------------------------------------------
# Build everything
# ------------------------------------------------------------------------

# Check source sanitary
ifneq ($(KBUILD_CHECKSRC),0)
  ifeq ($(KBUILD_CHECKSRC),2)
    quiet_cmd_force_checksrc = CHECK   $<
          cmd_force_checksrc = $(CHECK) $(CHECKFLAGS) $(c_flags) $< ;
  else
      quiet_cmd_checksrc     = CHECK   $<
            cmd_checksrc     = $(CHECK) $(CHECKFLAGS) $(c_flags) $< ;
  endif
endif

#
# Rule to compile a set of .o files into one .o file
#
# ------------------------------------------------------------------------
ifdef builtin-target
# Filter out vmSandix.ld
_obj-y = $(filter-out %.ld, $(obj-y))
# If the list is empty, create an empty built-in.o
quiet_cmd_link_o_target = LD $(quiet_modtag)  $@
      cmd_link_o_target = \
      			$(if $(strip $(_obj-y)),\
			$(LD) $(ld_flags) -r -o $@ $(_obj-y), \
			rm -f $@; $(AR) rcs$(KBUILD_ARFLAGS) $@)

$(builtin-target): $(obj-y) FORCE
	$(call if_changed,link_o_target)

targets += $(obj-y)
targets += $(builtin-target)
endif

#
# Rule to compile a set of .o files into one .a file
#
# ------------------------------------------------------------------------
ifdef lib-target
quiet_cmd_link_l_target = AR $(quiet_modtag)  $@
      cmd_link_l_target = rm -f $@; $(AR) rcs$(KBUILD_ARFLAGS) $@ $(lib-y)

$(lib-target): $(lib-y) FORCE
	$(call if_changed,link_l_target)

targets += $(lib-y)
targets += $(lib-target)
endif

#
# Rule to link composite objects
#
#  Composite objects are specified in kbuild makefile as follows:
#    <composite-object>-objs := <list of .o files>
#  or
#    <composite-object>-y    := <list of .o files>
#
# ------------------------------------------------------------------------
link_multi_deps =                     \
$(filter $(addprefix $(obj)/,         \
$($(subst $(obj)/,,$(@:.o=-objs)))    \
$($(subst $(obj)/,,$(@:.o=-y)))), $^)

quiet_cmd_link_multi-y = LD $(quiet_modtag)  $@
      cmd_link_multi-y = $(LD) $(ld_flags) -r -o $@ $(link_multi_deps) $(cmd_secanalysis)

$(multi-used-y): FORCE
	$(call if_changed,link_multi-y)
$(call multi_depend, $(multi-used-y), .o, -objs -y)

targets += $(multi-used-y)

#
# Rule to compile simple boot loader
#
# ------------------------------------------------------------------------
ifdef loader-target
quiet_cmd_loader = AS $(quiet_modtag)  $@
      cmd_loader = $(CC) $(a_flags) -c -o $@ $<

$(loader-target): $(patsubst %.o,%.S,$(loader-y)) 
	$(call if_changed_dep,loader)

targets += $(loader-target)
endif

#
# Rule to use objcopy
#
# ------------------------------------------------------------------------
ifdef objcopy-target
quiet_cmd_objcopy = OBJCOPY $@
      cmd_objcopy = $(OBJCOPY) $(objcopy_flags) $< $@

$(objcopy-target): $(objcopy-y) FORCE
	$(call if_changed_dep,objcopy)
endif

#
# Rule to use objdump
#
# ------------------------------------------------------------------------
ifdef objdump-target
quiet_cmd_objdump = OBJDUMP $@
      cmd_objdump = $(OBJDUMP) $(objdump_flags) $(patsubst %-objdump,%,$@) >$@

$(objdump-target): $(objdump-y) FORCE
	$(call if_changed_dep,objdump)
endif

# Descending into sub-directory
# ------------------------------------------------------------------------
$(sort $(subdir-obj-y)): $(subdir-y) ;
PHONY += $(subdir-y)
$(subdir-y):
	$(Q)$(MAKE) $(build)=$@

# Hmm, you see how $(targets) works?
# Read all saved command lines and dependencies for the $(targets) we
# may be building above, used by $(if_changed{,_dep,_rule}). 
# ------------------------------------------------------------------------
targets  := $(wildcard $(sort $(targets)))
depfiles := $(wildcard $(foreach f,$(targets),$(dir $(f)).$(notdir $(f)).d))
cmdfiles := $(wildcard $(foreach f,$(targets),$(dir $(f)).$(notdir $(f)).cmd))

ifneq ($(depfiles),)
  include $(depfiles)
endif
ifneq ($(cmdfiles),)
  include $(cmdfiles)
endif

# ------------------------------------------------------------------------
# Compile C sources (.c)
# ------------------------------------------------------------------------

# .c --> .s
quiet_cmd_cc_s_c = CC $(quiet_modtag)  $@
      cmd_cc_s_c = $(CC) $(c_flags) -fverbose-asm -S -o $@ $<

$(obj)/%.s: $(src)/%.c FORCE
	$(call if_changed_dep,cc_s_c)

# .c --> .i
quiet_cmd_cc_i_c = CPP $(quiet_modtag) $@
      cmd_cc_i_c = $(CPP) $(c_flags) -o $@ $<

$(obj)/%.i: $(src)/%.c FORCE
	$(call if_changed_dep,cc_i_c)

# .c --> .symtypes
cmd_gensymtypes =                                                   \
    $(CPP) -D__GENKSYMS__ $(c_flags) $< |                           \
    $(GENKSYMS) $(if $(1), -T $(2))                                 \
     $(patsubst y,-s _,$(CONFIG_HAVE_UNDERSCORE_SYMBOL_PREFIX))     \
     $(if $(KBUILD_PRESERVE),-p)                                    \
     -r $(firstword $(wildcard $(2:.symtypes=.symref) /dev/null))

quiet_cmd_cc_symtypes_c = SYM $(quiet_modtag) $@
      cmd_cc_symtypes_c =                                           \
          set -e;                                                   \
          $(call cmd_gensymtypes,true,$@) >/dev/null;               \
          test -s $@ || rm -f $@

$(obj)/%.symtypes : $(src)/%.c FORCE
	$(call cmd,cc_symtypes_c)

# .c --> .o
# The C file is compiled and updated dependency information is generated.
quiet_cmd_cc_o_c = CC $(quiet_modtag)  $@
      cmd_cc_o_c = $(CC) $(c_flags) -c -o $@ $<

# TODO
#define rule_cc_o_c
#	$(call echo-cmd,checksrc) $(cmd_checksrc)			  \
#	$(call echo-cmd,cc_o_c) $(cmd_cc_o_c);				  \
#	scripts/basic/fixdep $(depfile) $@ '$(call make-cmd,cc_o_c)' >    \
#	                                              $(dot-target).tmp;  \
#	rm -f $(depfile);						  \
#	mv -f $(dot-target).tmp $(dot-target).cmd
#endef

define rule_cc_o_c
	$(call echo-cmd,checksrc) $(cmd_checksrc)			  \
	$(call echo-cmd,cc_o_c) $(cmd_cc_o_c);
endef

# Built-in
#$(call cmd,force_checksrc)
$(obj)/%.o: $(src)/%.c FORCE
	$(call if_changed_rule,cc_o_c)

# ------------------------------------------------------------------------
# Compile Assembly Sources (.S)
# ------------------------------------------------------------------------

# .S --> .s
quiet_cmd_as_s_S = CPP $(quiet_modtag) $@
      cmd_as_s_S = $(CPP) $(a_flags) -o $@ $<

$(obj)/%.s: $(src)/%.S FORCE
	$(call if_changed_dep,as_s_S)

# .S --> .o
quiet_cmd_as_o_S = AS $(quiet_modtag)  $@
      cmd_as_o_S = $(CC) $(a_flags) -c -o $@ $<

$(obj)/%.o: $(src)/%.S FORCE
	$(call if_changed_dep,as_o_S)

# ------------------------------------------------------------------------
# Linker scripts preprocessor (.ld.S -> .ld)
# ------------------------------------------------------------------------

# .ld.S --> .ld
quiet_cmd_cpp_ld_S = LDS $(quiet_modtag) $@
      cmd_cpp_ld_S = $(CPP) $(cpp_flags) -P -C -D__ASSEMBLY__ -DLINKER_SCRIPT -o $@ $<

$(obj)/%.ld: $(src)/%.ld.S FORCE
	$(call if_changed_dep,cpp_ld_S)


# Add FORCE to prequisites of a target to force it to be always rebuilt.
# ------------------------------------------------------------------------
PHONY += FORCE
FORCE:

# Declare the contents of the .PHONY variable as phony.  We keep that
# information in a variable se we can use it in if_changed.
.PHONY: $(PHONY)
