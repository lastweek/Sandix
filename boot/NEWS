2015/04/14. 

Call C functions from assemble is a little tricky.
As designs, the bootsect do not need link. but header.s, main.c and so on need to
be linked together to form the real-mode kernel image. Because the link process
is done under 16-bit mode, maybe it's a little different from 32-bit linking.

Tonight i tried to link header.o and main.o together which brings some difficult.
So, in my opinion, i should try to learn ld scripts to get things done more efficency.

When we met some fucking error that we tried very very hard to find, just read
the dame fucking assembler code!



2015/04/15

Today i tried using i386-elf-gcc-4.72 to generate assembler file.
In the fucking real-mode, a call instruction just push 2bytes into stack,
but gcc-4.72 use 8(%ebp) to get the first argument by default!!! It should use 6(%ebp)!!!!

Whatever, gcc-4.72 can do nothing about this. So i wanna download gcc-5.1 source code, build
a cross-compile. You know how long compilation will take??!!!!!!

Before download gcc, i tried compile with my native gcc-4.9.2 -m16. It turns out the code still
use 8(%ebp) to get the argument.

Maybe there are some other opinions about stack alignment.

Problem solved: Use -mregparm=3. Got this from linux-3.18 kernel Makefile!!!!!



2015/04/16

New problem... gcc generate LEAVE instead of LEAVEL. LEAVE pop 3bytes to bp, LEAVEL pop 4bytes to ebp.
We need LEAVEL not LEAVE!!!
How to control gcc generate LEAVEL instead of LEAVE????
After thinking, it seems that gcc won't generate LEAVEL. Cause in gcc's mind, he always in 32-bit mode.

Maybe Assembler can add prefix 0x66 before LEAVE.

This is some note useless:
# Something about -mregparm=3:
#	Real-Mode call instruction push 2 bytes IP into stack. When procedure AA
#	make a call to procedure BB, the first argument AA passes to BB is located
#	at 6(%ebp). However, GCC donot know this! In GCC's mind, the first argument
#	should be at 8(%ebp). Using -mregparam to pass arguments by registers avoids
#	such fatal problem. See code yourself.


2015/04/17

TODAY IS A BIG DAY.
MANY THANKS TO GNU ASSEMBLER AND .CODE16GCC

1. USE .code16gcc INSTEAD OF .code16. The first directive tells AS that the assembler
   code was generated by GCC. When AS see this directive, AS knows that one guy is trying
   to write 16-bit code with C language! So AS will add prefix 0x66&0x67 automatically
   before [call], [ret], [leave], [jmp](and so on). Before today i really really haven't
   seen if there exist some differences between .code16gcc and .code16.

2. Ok now we have .code16gcc to fire. Although we are still run in Real-Mode, but the
   most important instructions like call, ret, leave, push now all have 32-bit prefixes,
   which means they all operate in 4-byte world! Call is calll, ret is retl, leave is leavel.

3. Now we really dont need -mregparm anymore. The reason is we are in a "32-bit" Real-Mode,
   calll pushs 4bytes into stack. BTW, the code generated with -mregparam opinion is some
   kind of redundant. In some code, the caller put arguments in eax-edx-ecx, but the callee
   push the three registers into stack first, then use arguments in stack.

4. Conclusion: problem raised yesterday is solved! Just use .code16gcc instead of .code16,
   we are free in Read-Mode C programming!!!


2015/04/19

As we are adding more code to 16-bit setup image, the image is fatter than before.
We have to pay 100% attention to how to set [%sp], which can't too high nor too low.
In addition, pay attention to bootsect.s, change the loading sector numbers of image.
Make sure we have load all sectors of image to main memory.

2015/04/20

I spend 3 hours trying to find out what's the damn bug in my printf. It turns out that 
it's not the bug's problem. It's my problem! I totally forgot what i said yerterday:
Change the sectors of header need to be loaded into memory. The header this afternoon
is about 3600 bytes, but bootsect.s only load 7 sectors, that's why.


2015/04/21

Today is my first time use IO port instruction! There is an interesting port: 0x80.
Most systems use 0x80 to generate an IO delay. No matter read or write to this port,
it won't have reaction, and we will get about 1 microsecond delay. Someone say this
port is used by BIOS in POST.

2015/04/22

0.	Intel software-developer-volume-3-part-1:
	Chapter 3---Protected-mode memory management.

	Consult this volume for more detailed information.

1.	X86 Memory-management registers: GDTR and IDTR, LDTR and TR.
	GDT and IDT are NOT considered to be segment.
	LDT and TSS are     considered to be segment in GDT, they have segment descriptors.

	X86 architecture defines two system [segment], the task-state segment(TSS) and LDT.
	The GDT is not considered a segment because it is not accessed by means of a segment
	selector or a segment descriptor! TSS and LDT have [segment descriptors] in GDT defined
	for them!!!

	###TSS and LDT are system SEGMENT!!! They have descriptors in GDT!!!###

	An LDT is accessed with its segment selector. To eliminate address translations when
	accessing the LDT, the segment selector, base linear address, limit, and access rights
	of the LDT are stored in the LDTR register

2.	Segment Descriptor: 8 bytes each. 

	bit S    (1 bit):	Descriptor type (0 = system; 1 = code or data)
	bit TYPE (4 bit):	Segment type
	__________________________________________________________________
	S = 1					|  Segment TYPE							 |
	------------------------------------------------------------------
	Non-System decriptors:	|* Code segment							 |
							|* Data segment							 |
	------------------------------------------------------------------
	S = 0					|  Segment TYPE							 |
	------------------------------------------------------------------
	System descriptors:		|* LDT segment descriptor			 	 |
							|* Task-state segment(TSS) descriptor	 |
							|										 |
							|* Call-gate Descriptor					 |
							|* Interrupt-gate Descriptor			 |
							|* Trap-gate descriptor					 |
							|* Task-gate descriptor					 |
	________________________|________________________________________|

3.	Under protected mode, the CS and DS and SS must be loaded with valid segment selectors.
	
	Visable part(16 bit)		Hidden part(Descriptor cache; Shadow cache)
	______________________________________________________________
	| segment selector  | Base address, Limit, Access information |		CS
	|___________________|_________________________________________|
	______________________________________________________________
	| segment selector  | Base address, Limit, Access information |		DS
	|___________________|_________________________________________|
	______________________________________________________________
	| segment selector  | Base address, Limit, Access information |		SS ES FS GS
	|___________________|_________________________________________|


2015/04/24

Memory			...Done
Interrupt
Keyboard
Screen
Disk

Today's job: Get through video setup, save parameters or something
			 Maybe store EDD information, if i got time.
