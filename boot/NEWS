2015/04/14. 

Call C functions from assemble is a little tricky.
As designs, the bootsect do not need link. but header.s, main.c and so on need to
be linked together to form the real-mode kernel image. Because the link process
is done under 16-bit mode, maybe it's a little different from 32-bit linking.

Tonight i tried to link header.o and main.o together which brings some difficult.
So, in my opinion, i should try to learn ld scripts to get things done more efficency.

When we met some fucking error that we tried very very hard to find, just read
the dame fucking assembler code!



2015/04/15

Today i tried using i386-elf-gcc-4.72 to generate assembler file.
In the fucking real-mode, a call instruction just push 2bytes into stack,
but gcc-4.72 use 8(%ebp) to get the first argument by default!!! It should use 6(%ebp)!!!!

Whatever, gcc-4.72 can do nothing about this. So i wanna download gcc-5.1 source code, build
a cross-compile. You know how long compilation will take??!!!!!!

Before download gcc, i tried compile with my native gcc-4.9.2 -m16. It turns out the code still
use 8(%ebp) to get the argument.

Maybe there are some other opinions about stack alignment.

Problem solved: Use -mregparm=3. Got this from linux-3.18 kernel Makefile!!!!!



2015/04/16

New problem... gcc generate LEAVE instead of LEAVEL. LEAVE pop 3bytes to bp, LEAVEL pop 4bytes to ebp.
We need LEAVEL not LEAVE!!!
How to control gcc generate LEAVEL instead of LEAVE????
After thinking, it seems that gcc won't generate LEAVEL. Cause in gcc's mind, he always in 32-bit mode.

Maybe Assembler can add prefix 0x66 before LEAVE.

This is some note useless:
# Something about -mregparm=3:
#	Real-Mode call instruction push 2 bytes IP into stack. When procedure AA
#	make a call to procedure BB, the first argument AA passes to BB is located
#	at 6(%ebp). However, GCC donot know this! In GCC's mind, the first argument
#	should be at 8(%ebp). Using -mregparam to pass arguments by registers avoids
#	such fatal problem. See code yourself.


2015/04/17

TODAY IS A BIG DAY.
MANY THANKS TO GNU ASSEMBLER AND .CODE16GCC

1. USE .code16gcc INSTEAD OF .code16. The first directive tells AS that the assembler
   code was generated by GCC. When AS see this directive, AS knows that one guy is trying
   to write 16-bit code with C language! So AS will add prefix 0x66&0x67 automatically
   before [call], [ret], [leave], [jmp](and so on). Before today i really really haven't
   seen if there exist some differences between .code16gcc and .code16.

2. Ok now we have .code16gcc to fire. Although we are still run in Real-Mode, but the
   most important instructions like call, ret, leave, push now all have 32-bit prefixes,
   which means they all operate in 4-byte world! Call is calll, ret is retl, leave is leavel.

3. Now we really dont need -mregparm anymore. The reason is we are in a "32-bit" Real-Mode,
   calll pushs 4bytes into stack. BTW, the code generated with -mregparam opinion is some
   kind of redundant. In some code, the caller put arguments in eax-edx-ecx, but the callee
   push the three registers into stack first, then use arguments in stack.

4. Conclusion: problem raised yesterday is solved! Just use .code16gcc instead of .code16,
   we are free in Read-Mode C programming!!!


2015/04/19

As we are adding more code to 16-bit setup image, the image is fatter than before.
We have to pay 100% attention to how to set [%sp], which can't too high nor too low.
In addition, pay attention to bootsect.s, change the loading sector numbers of image.
Make sure we have load all sectors of image to main memory.

2015/04/20

I spend 3 hours trying to find out what's the damn bug in my printf. It turns out that 
it's not the bug's problem. It's my problem! I totally forgot what i said yerterday:
Change the sectors of header need to be loaded into memory. The header this afternoon
is about 3600 bytes, but bootsect.s only load 7 sectors, that's why.

