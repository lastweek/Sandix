config ARCH
	string
	option env="ARCH"

config KERNELVERSION
	string
	option env="KERNELVERSION"

menu "General setup"

config CROSS_COMPILE
	string "Cross-compiler tool prefix"
	help
	  Same as running 'make CROSS_COMPILE=prefix-' but stored for
	  default make runs in this kernel build directory.  You don't
	  need to set this unless you want the configured kernel build
	  directory to select the cross-compiler automatically.

config LOCALVERSION
	string "Local version - append to kernel release"
	help
	  Append an extra string to the end of your kernel version.
	  This will show up when you type uname, for example.
	  The string you set here will be appended after the contents of
	  any files with a filename matching localversion* in your
	  object and source tree, in that order.  Your total string can
	  be a maximum of 64 characters.

config LOCALVERSION_AUTO
	bool "Automatically append version information to the version string"
	default y
	help
	  This will try to automatically determine if the current tree is a
	  release tree by looking for git tags that belong to the current
	  top of tree revision.

	  A string of the format -gxxxxxxxx will be added to the localversion
	  if a git-based tree is found.  The string generated by this will be
	  appended after any matching localversion* files, and after the value
	  set in CONFIG_LOCALVERSION.

	  (The actual string used here is the first eight characters produced
	  by running the command:

	    $ git rev-parse --verify HEAD

	  which is done within the script "scripts/setlocalversion".)

config HAVE_KERNEL_GZIP
	bool

config HAVE_KERNEL_BZIP2
	bool

config HAVE_KERNEL_LZMA
	bool

config HAVE_KERNEL_XZ
	bool

config HAVE_KERNEL_LZO
	bool

config HAVE_KERNEL_LZ4
	bool

choice
	prompt "Kernel compression mode"
	default KERNEL_GZIP
	depends on HAVE_KERNEL_GZIP || HAVE_KERNEL_BZIP2 || HAVE_KERNEL_LZMA || HAVE_KERNEL_XZ || HAVE_KERNEL_LZO || HAVE_KERNEL_LZ4
	help
	  The linux kernel is a kind of self-extracting executable.
	  Several compression algorithms are available, which differ
	  in efficiency, compression and decompression speed.
	  Compression speed is only relevant when building a kernel.
	  Decompression speed is relevant at each boot.

	  If you have any problems with bzip2 or lzma compressed
	  kernels, mail me (Alain Knaff) <alain@knaff.lu>. (An older
	  version of this functionality (bzip2 only), for 2.4, was
	  supplied by Christian Ludwig)

	  High compression options are mostly useful for users, who
	  are low on disk space (embedded systems), but for whom ram
	  size matters less.

	  If in doubt, select 'gzip'

config KERNEL_GZIP
	bool "Gzip"
	depends on HAVE_KERNEL_GZIP
	help
	  The old and tried gzip compression. It provides a good balance
	  between compression ratio and decompression speed.

config KERNEL_BZIP2
	bool "Bzip2"
	depends on HAVE_KERNEL_BZIP2
	help
	  Its compression ratio and speed is intermediate.
	  Decompression speed is slowest among the choices.  The kernel
	  size is about 10% smaller with bzip2, in comparison to gzip.
	  Bzip2 uses a large amount of memory. For modern kernels you
	  will need at least 8MB RAM or more for booting.

config KERNEL_LZMA
	bool "LZMA"
	depends on HAVE_KERNEL_LZMA
	help
	  This compression algorithm's ratio is best.  Decompression speed
	  is between gzip and bzip2.  Compression is slowest.
	  The kernel size is about 33% smaller with LZMA in comparison to gzip.

config KERNEL_XZ
	bool "XZ"
	depends on HAVE_KERNEL_XZ
	help
	  XZ uses the LZMA2 algorithm and instruction set specific
	  BCJ filters which can improve compression ratio of executable
	  code. The size of the kernel is about 30% smaller with XZ in
	  comparison to gzip. On architectures for which there is a BCJ
	  filter (i386, x86_64, ARM, IA-64, PowerPC, and SPARC), XZ
	  will create a few percent smaller kernel than plain LZMA.

	  The speed is about the same as with LZMA: The decompression
	  speed of XZ is better than that of bzip2 but worse than gzip
	  and LZO. Compression is slow.

config KERNEL_LZO
	bool "LZO"
	depends on HAVE_KERNEL_LZO
	help
	  Its compression ratio is the poorest among the choices. The kernel
	  size is about 10% bigger than gzip; however its speed
	  (both compression and decompression) is the fastest.

config KERNEL_LZ4
	bool "LZ4"
	depends on HAVE_KERNEL_LZ4
	help
	  LZ4 is an LZ77-type compressor with a fixed, byte-oriented encoding.
	  A preliminary version of LZ4 de/compression tool is available at
	  <https://code.google.com/p/lz4/>.

	  Its compression ratio is worse than LZO. The size of the kernel
	  is about 8% bigger than LZO. But the decompression speed is
	  faster than LZO.

endchoice

config DEFAULT_HOSTNAME
	string "Default hostname"
	default "(none)"
	help
	  This option determines the default system hostname before userspace
	  calls sethostname(2). The kernel traditionally uses "(none)" here,
	  but you may wish to use a different default here to make a minimal
	  system more usable with less configuration.

#
# This is for *anonymous pages*
#
config SWAP
	bool "Support for paging of anonymous memory (swap)"
	depends on MMU && BLOCK
	default y
	help
	  This option allows you to choose whether you want to have support
	  for so called swap devices or swap files in your kernel that are
	  used to provide more virtual memory than the actual RAM present
	  in your computer.  If unsure say Y.


menu "CPU/Task time and stats accouting"

config VIRT_CPU_ACCOUNTING
	bool

choice
	prompt "Cputime accounting"
	default TICK_CPU_ACCOUNTING if !PPC64
	default VIRT_CPU_ACCOUNTING_NATIVE if PPC64

# Kind of a stub config for the pure tick based cputime accounting
config TICK_CPU_ACCOUNTING
	bool "Simple tick based cputime accounting"
	depends on !S390 && !NO_HZ_FULL
	help
	  This is the basic tick based cputime accounting that maintains
	  statistics about user, system and idle time spent on per jiffies
	  granularity.

	  If unsure, say Y.

config VIRT_CPU_ACCOUNTING_NATIVE
	bool "Deterministic task and CPU time accounting"
	depends on HAVE_VIRT_CPU_ACCOUNTING && !NO_HZ_FULL
	select VIRT_CPU_ACCOUNTING
	help
	  Select this option to enable more accurate task and CPU time
	  accounting.  This is done by reading a CPU counter on each
	  kernel entry and exit and on transitions within the kernel
	  between system, softirq and hardirq state, so there is a
	  small performance impact.  In the case of s390 or IBM POWER > 5,
	  this also enables accounting of stolen time on logically-partitioned
	  systems.

config VIRT_CPU_ACCOUNTING_GEN
	bool "Full dynticks CPU time accounting"
	depends on HAVE_CONTEXT_TRACKING
	depends on HAVE_VIRT_CPU_ACCOUNTING_GEN
	select VIRT_CPU_ACCOUNTING
	select CONTEXT_TRACKING
	help
	  Select this option to enable task and CPU time accounting on full
	  dynticks systems. This accounting is implemented by watching every
	  kernel-user boundaries using the context tracking subsystem.
	  The accounting is thus performed at the expense of some significant
	  overhead.

	  For now this is only useful if you are working on the full
	  dynticks subsystem development.

	  If unsure, say N.

config IRQ_TIME_ACCOUNTING
	bool "Fine granularity task level IRQ time accounting"
	depends on HAVE_IRQ_TIME_ACCOUNTING && !NO_HZ_FULL
	help
	  Select this option to enable fine granularity task irq time
	  accounting. This is done by reading a timestamp on each
	  transitions between softirq and hardirq state, so there can be a
	  small performance impact.

	  If in doubt, say N here.

endchoice

config TASK_DELAY_ACCT
	bool "Enable per-task delay accounting"
	depends on TASKSTATS
	select SCHED_INFO
	help
	  Collect information on time spent by a task waiting for system
	  resources like cpu, synchronous block I/O completion and swapping
	  in pages. Such statistics can help in setting a task's priorities
	  relative to other tasks for cpu, io, rss limits etc.

	  Say N if unsure.

config TASK_IO_ACCOUNTING
	bool "Enable per-task storage I/O accounting"
	depends on TASK_XACCT
	help
	  Collect information on the number of bytes of storage I/O which this
	  task has caused.

	  Say N if unsure.

endmenu # "CPU/Task time and stats accounting"

config LOG_BUF_SHIFT
	int "Kernel log buffer size (16 => 64KB, 17 => 128KB)"
	range 12 25
	default 17
	depends on PRINTK
	help
	  Select the minimal kernel log buffer size as a power of 2.
	  The final size is affected by LOG_CPU_MAX_BUF_SHIFT config
	  parameter, see below. Any higher size also might be forced
	  by "log_buf_len" boot parameter.

	  Examples:
		     17 => 128 KB
		     16 => 64 KB
		     15 => 32 KB
		     14 => 16 KB
		     13 =>  8 KB
		     12 =>  4 KB

config LOG_CPU_MAX_BUF_SHIFT
	int "CPU kernel log buffer size contribution (13 => 8 KB, 17 => 128KB)"
	depends on SMP
	range 0 21
	default 12 if !BASE_SMALL
	default 0 if BASE_SMALL
	depends on PRINTK
	help
	  This option allows to increase the default ring buffer size
	  according to the number of CPUs. The value defines the contribution
	  of each CPU as a power of 2. The used space is typically only few
	  lines however it might be much more when problems are reported,
	  e.g. backtraces.

	  The increased size means that a new buffer has to be allocated and
	  the original static one is unused. It makes sense only on systems
	  with more CPUs. Therefore this value is used only when the sum of
	  contributions is greater than the half of the default kernel ring
	  buffer as defined by LOG_BUF_SHIFT. The default values are set
	  so that more than 64 CPUs are needed to trigger the allocation.

	  Also this option is ignored when "log_buf_len" kernel parameter is
	  used as it forces an exact (power of two) size of the ring buffer.

	  The number of possible CPUs is used for this computation ignoring
	  hotplugging making the compuation optimal for the the worst case
	  scenerio while allowing a simple algorithm to be used from bootup.

	  Examples shift values and their meaning:
		     17 => 128 KB for each CPU
		     16 =>  64 KB for each CPU
		     15 =>  32 KB for each CPU
		     14 =>  16 KB for each CPU
		     13 =>   8 KB for each CPU
		     12 =>   4 KB for each CPU

config NMI_LOG_BUF_SHIFT
	int "Temporary per-CPU NMI log buffer size (12 => 4KB, 13 => 8KB)"
	range 10 21
	default 13
	depends on PRINTK_NMI
	help
	  Select the size of a per-CPU buffer where NMI messages are temporary
	  stored. They are copied to the main log buffer in a safe context
	  to avoid a deadlock. The value defines the size as a power of 2.

	  NMI messages are rare and limited. The largest one is when
	  a backtrace is printed. It usually fits into 4KB. Select
	  8KB if you want to be on the safe side.

	  Examples:
		     17 => 128 KB for each CPU
		     16 =>  64 KB for each CPU
		     15 =>  32 KB for each CPU
		     14 =>  16 KB for each CPU
		     13 =>   8 KB for each CPU
		     12 =>   4 KB for each CPU

#
# For architectures that want to enable the support for NUMA-affine scheduler
# balancing logic:
#
config ARCH_SUPPORTS_NUMA_BALANCING
	bool

#
# For architectures that prefer to flush all TLBs after a number of pages
# are unmapped instead of sending one IPI per page to flush. The architecture
# must provide guarantees on what happens if a clean TLB cache entry is
# written after the unmap. Details are in mm/rmap.c near the check for
# should_defer_flush. The architecture should also consider if the full flush
# and the refill costs are offset by the savings of sending fewer IPIs.
#
config ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH
	bool

#
# For architectures that (ab)use NUMA to represent different memory regions
# all cpu-local but of different latencies, such as SuperH.
#
config ARCH_WANT_NUMA_VARIABLE_LOCALITY
	bool

config NUMA_BALANCING
	bool "Memory placement aware NUMA scheduler"
	depends on ARCH_SUPPORTS_NUMA_BALANCING
	depends on !ARCH_WANT_NUMA_VARIABLE_LOCALITY
	depends on SMP && NUMA && MIGRATION
	help
	  This option adds support for automatic NUMA aware memory/task placement.
	  The mechanism is quite primitive and is based on migrating memory when
	  it has references to the node the task is running on.

	  This system will be inactive on UMA systems.

config NUMA_BALANCING_DEFAULT_ENABLED
	bool "Automatically enable NUMA aware memory/task placement"
	default y
	depends on NUMA_BALANCING
	help
	  If set, automatic NUMA balancing will be enabled if running on a NUMA
	  machine.

config BLK_DEV_INITRD
	bool "Initial RAM filesystem and RAM disk (initramfs/initrd) support"
	depends on BROKEN || !FRV
	help
	  The initial RAM filesystem is a ramfs which is loaded by the
	  boot loader (loadlin or lilo) and that is mounted as root
	  before the normal boot procedure. It is typically used to
	  load modules needed to mount the "real" root file system,
	  etc. See <file:Documentation/initrd.txt> for details.

	  If RAM disk support (BLK_DEV_RAM) is also included, this
	  also enables initial RAM disk (initrd) support and adds
	  15 Kbytes (more on some other architectures) to the kernel size.

	  If unsure say Y.

config CC_OPTIMIZE_FOR_SIZE
	bool "Optimize for size"
	help
	  Enabling this option will pass "-Os" instead of "-O2" to
	  your compiler resulting in a smaller kernel.

	  If unsure, say N.

config VM_EVENT_COUNTERS
	default y
	bool "Enable VM event counters for /proc/vmstat" if EXPERT
	help
	  VM event counters are needed for event counts to be shown.
	  This option allows the disabling of the VM event counters
	  on EXPERT systems.  /proc/vmstat will only show page counts
	  if VM event counters are disabled.

choice
	prompt "Choose SLAB allocator"
	default SLUB
	help
	   This option allows to select a slab allocator.

config SLAB
	bool "SLAB"
	help
	  The regular slab allocator that is established and known to work
	  well in all environments. It organizes cache hot objects in
	  per cpu and per node queues.

config SLUB
	bool "SLUB (Unqueued Allocator)"
	help
	   SLUB is a slab allocator that minimizes cache line usage
	   instead of managing queues of cached objects (SLAB approach).
	   Per cpu caching is realized using slabs of objects instead
	   of queues of objects. SLUB can use memory efficiently
	   and has enhanced diagnostics. SLUB is the default choice for
	   a slab allocator.

config SLOB
	depends on EXPERT
	bool "SLOB (Simple Allocator)"
	help
	   SLOB replaces the stock allocator with a drastically simpler
	   allocator. SLOB is generally more space efficient but
	   does not perform as well on large systems.

endchoice

config SLAB_FREELIST_RANDOM
	default n
	depends on SLAB
	bool "SLAB freelist randomization"
	help
	  Randomizes the freelist order used on creating new SLABs. This
	  security feature reduces the predictability of the kernel slab
	  allocator against heap overflows.

config SLUB_CPU_PARTIAL
	default y
	depends on SLUB && SMP
	bool "SLUB per cpu partial cache"
	help
	  Per cpu partial caches accellerate objects allocation and freeing
	  that is local to a processor at the price of more indeterminism
	  in the latency of the free. On overflow these caches will be cleared
	  which requires the taking of locks that may cause latency spikes.
	  Typically one would choose no for a realtime system.

config MMAP_ALLOW_UNINITIALIZED
	bool "Allow mmapped anonymous memory to be uninitialized"
	depends on EXPERT && !MMU
	default n
	help
	  Normally, and according to the Linux spec, anonymous memory obtained
	  from mmap() has it's contents cleared before it is passed to
	  userspace.  Enabling this config option allows you to request that
	  mmap() skip that if it is given an MAP_UNINITIALIZED flag, thus
	  providing a huge performance boost.  If this option is not enabled,
	  then the flag will be ignored.

	  This is taken advantage of by uClibc's malloc(), and also by
	  ELF-FDPIC binfmt's brk and stack allocator.

	  Because of the obvious security issues, this option should only be
	  enabled on embedded devices where you control what is run in
	  userspace.  Since that isn't generally a problem on no-MMU systems,
	  it is normally safe to say Y here.

	  See Documentation/nommu-mmap.txt for more information.

config PROFILING
	bool "Profiling support"
	help
	  Say Y here to enable the extended profiling support mechanisms used
	  by profilers such as OProfile.

endmenu # General setup

menuconfig MODULES
	bool "Enable loadable module support"
	option modules
	help
	  Kernel modules are small pieces of compiled code which can
	  be inserted in the running kernel, rather than being
	  permanently built into the kernel.  You use the "modprobe"
	  tool to add (and sometimes remove) them.  If you say Y here,
	  many parts of the kernel can be built as modules (by
	  answering M instead of Y where indicated): this is most
	  useful for infrequently used options which are not required
	  for booting.  For more information, see the man pages for
	  modprobe, lsmod, modinfo, insmod and rmmod.

	  If you say Y here, you will need to run "make
	  modules_install" to put the modules under /lib/modules/
	  where modprobe can find them (you may need to be root to do
	  this).

	  If unsure, say Y.

if MODULES

config MODULE_FORCE_LOAD
	bool "Forced module loading"
	default n
	help
	  Allow loading of modules without version information (ie. modprobe
	  --force).  Forced module loading sets the 'F' (forced) taint flag and
	  is usually a really bad idea.

config MODULE_UNLOAD
	bool "Module unloading"
	help
	  Without this option you will not be able to unload any
	  modules (note that some modules may not be unloadable
	  anyway), which makes your kernel smaller, faster
	  and simpler.  If unsure, say Y.

config MODULE_FORCE_UNLOAD
	bool "Forced module unloading"
	depends on MODULE_UNLOAD
	help
	  This option allows you to force a module to unload, even if the
	  kernel believes it is unsafe: the kernel will remove the module
	  without waiting for anyone to stop using it (using the -f option to
	  rmmod).  This is mainly for kernel developers and desperate users.
	  If unsure, say N.

config MODVERSIONS
	bool "Module versioning support"
	help
	  Usually, you have to use modules compiled with your kernel.
	  Saying Y here makes it sometimes possible to use modules
	  compiled for different kernels, by adding enough information
	  to the modules to (hopefully) spot any changes which would
	  make them incompatible with the kernel you are running.  If
	  unsure, say N.

config MODULE_SRCVERSION_ALL
	bool "Source checksum for all modules"
	help
	  Modules which contain a MODULE_VERSION get an extra "srcversion"
	  field inserted into their modinfo section, which contains a
    	  sum of the source files which made it.  This helps maintainers
	  see exactly which source was used to build a module (since
	  others sometimes change the module source without updating
	  the version).  With this option, such a "srcversion" field
	  will be created for all modules.  If unsure, say N.

config MODULE_SIG
	bool "Module signature verification"
	depends on MODULES
	select SYSTEM_DATA_VERIFICATION
	help
	  Check modules for valid signatures upon load: the signature
	  is simply appended to the module. For more information see
	  Documentation/module-signing.txt.

	  Note that this option adds the OpenSSL development packages as a
	  kernel build dependency so that the signing tool can use its crypto
	  library.

	  !!!WARNING!!!  If you enable this option, you MUST make sure that the
	  module DOES NOT get stripped after being signed.  This includes the
	  debuginfo strip done by some packagers (such as rpmbuild) and
	  inclusion into an initramfs that wants the module size reduced.

config MODULE_SIG_FORCE
	bool "Require modules to be validly signed"
	depends on MODULE_SIG
	help
	  Reject unsigned modules or signed modules for which we don't have a
	  key.  Without this, such modules will simply taint the kernel.

config MODULE_SIG_ALL
	bool "Automatically sign all modules"
	default y
	depends on MODULE_SIG
	help
	  Sign all modules during make modules_install. Without this option,
	  modules must be signed manually, using the scripts/sign-file tool.

comment "Do not forget to sign required modules with scripts/sign-file"
	depends on MODULE_SIG_FORCE && !MODULE_SIG_ALL

choice
	prompt "Which hash algorithm should modules be signed with?"
	depends on MODULE_SIG
	help
	  This determines which sort of hashing algorithm will be used during
	  signature generation.  This algorithm _must_ be built into the kernel
	  directly so that signature verification can take place.  It is not
	  possible to load a signed module containing the algorithm to check
	  the signature on that module.

config MODULE_SIG_SHA1
	bool "Sign modules with SHA-1"
	select CRYPTO_SHA1

config MODULE_SIG_SHA224
	bool "Sign modules with SHA-224"
	select CRYPTO_SHA256

config MODULE_SIG_SHA256
	bool "Sign modules with SHA-256"
	select CRYPTO_SHA256

config MODULE_SIG_SHA384
	bool "Sign modules with SHA-384"
	select CRYPTO_SHA512

config MODULE_SIG_SHA512
	bool "Sign modules with SHA-512"
	select CRYPTO_SHA512

endchoice

config MODULE_SIG_HASH
	string
	depends on MODULE_SIG
	default "sha1" if MODULE_SIG_SHA1
	default "sha224" if MODULE_SIG_SHA224
	default "sha256" if MODULE_SIG_SHA256
	default "sha384" if MODULE_SIG_SHA384
	default "sha512" if MODULE_SIG_SHA512

config MODULE_COMPRESS
	bool "Compress modules on installation"
	depends on MODULES
	help

	  Compresses kernel modules when 'make modules_install' is run; gzip or
	  xz depending on "Compression algorithm" below.

	  module-init-tools MAY support gzip, and kmod MAY support gzip and xz.

	  Out-of-tree kernel modules installed using Kbuild will also be
	  compressed upon installation.

	  Note: for modules inside an initrd or initramfs, it's more efficient
	  to compress the whole initrd or initramfs instead.

	  Note: This is fully compatible with signed modules.

	  If in doubt, say N.

choice
	prompt "Compression algorithm"
	depends on MODULE_COMPRESS
	default MODULE_COMPRESS_GZIP
	help
	  This determines which sort of compression will be used during
	  'make modules_install'.

	  GZIP (default) and XZ are supported.

config MODULE_COMPRESS_GZIP
	bool "GZIP"

config MODULE_COMPRESS_XZ
	bool "XZ"

endchoice

endif # MODULES
