#
#	x86 ISA Configuration
#
#	Thanks, linux kernel hackers.
#

###
# Select 32 or 64 bit
###
config 64BIT
	bool "64-bit kernel"
	---help---
	Say yes to build a 64-bit kernel - formerly known as x86_64
	Say no to build a 32-bit kernel - formely known as i386

config X86_32
	def_bool y
	depends on !64BIT

config X86_64
	def_bool y
	depends on 64BIT

###
# Arch settings
###
menu	"Processor type and features"

config X86
	def_bool y
	select HAVE_ARCH_JUMP_LABEL
	select HAVE_KERNEL_BZIP2
	select HAVE_KERNEL_GZIP
	select HAVE_KERNEL_LZ4
	select HAVE_KERNEL_LZMA
	select HAVE_KERNEL_LZO
	select HAVE_KERNEL_X

config OUTPUT_FORMAT
	string
	default "elf32-i386" if X86_32
	default "elf64-x86-64" if X86_64

config ARCH_DEFCONFIG
	string
	default "arch/x86/configs/i386_defconfig" if X86_32
	default "arch/x86/configs/x86_64_defconfig" if X86_64

config MMU
	def_bool y

config ARCH_HAS_CPU_RELAX
	def_bool y

config ARCH_HAS_CACHE_LINE_SIZE
	def_bool y

config X86_32_SMP
	def_bool y
	depends on X86_32 && SMP

config X86_64_SMP
	def_bool y
	depends on X86_64 && SMP

config PGTABLE_LEVELS
	int
	default 4 if X86_64
	default 3 if X86_PAE
	default 2

config SMP
	bool "Symmetric multi-processing support"
	---help---
	  This enables support for systems with more than one CPU. If you have
	  a system with only one CPU, say N. If you have a system with more
	  than one CPU, say Y.

	  If you say N here, the kernel will run on uni- and multiprocessor
	  machines, but will use only one CPU of a multiprocessor machine. If
	  you say Y here, the kernel will run on many, but not all,
	  uniprocessor machines. On a uniprocessor machine, the kernel
	  will run faster if you say N here.

	  Note that if you say Y here and choose architecture "586" or
	  "Pentium" under "Processor family", the kernel will not work on 486
	  architectures. Similarly, multiprocessor kernels for the "PPro"
	  architecture may not work on all Pentium based boards.

	  People using multiprocessor machines who say Y here should also say
	  Y to "Enhanced Real Time Clock Support", below. The "Advanced Power
	  Management" code will be disabled if you say Y here.

	  See also <file:Documentation/x86/i386/IO-APIC.txt>,
	  <file:Documentation/nmi_watchdog.txt> and the SMP-HOWTO available at
	  <http://www.tldp.org/docs.html#howto>.

	  If you don't know what to do here, say N.

config MAXSMP
	bool "Enable Maximum number of SMP Processors and NUMA Nodes"
	depends on X86_64 && SMP && DEBUG_KERNEL
	select CPUMASK_OFFSTACK
	---help---
	  Enable maximum number of CPUS and NUMA Nodes for this architecture.
	  If unsure, say N.

config NR_CPUS
	int "Maximum number of CPUs" if SMP && !MAXSMP
	range 2 8 if SMP && X86_32 && !X86_BIGSMP
	range 2 512 if SMP && !MAXSMP && !CPUMASK_OFFSTACK
	range 2 8192 if SMP && !MAXSMP && CPUMASK_OFFSTACK && X86_64
	default "1" if !SMP
	default "8192" if MAXSMP
	default "32" if SMP && X86_BIGSMP
	default "8" if SMP && X86_32
	default "64" if SMP
	---help---
	  This allows you to specify the maximum number of CPUs which this
	  kernel will support.  If CPUMASK_OFFSTACK is enabled, the maximum
	  supported value is 8192, otherwise the maximum value is 512.  The
	  minimum value which makes sense is 2.

	  This is purely to save memory - each supported CPU adds
	  approximately eight kilobytes to the kernel image.

choice
	prompt "High Memory Support"
	default HIGHMEM4G
	depends on X86_32

config NOHIGHMEM
	bool "off"
	---help---
	  Linux can use up to 64 Gigabytes of physical memory on x86 systems.
	  However, the address space of 32-bit x86 processors is only 4
	  Gigabytes large. That means that, if you have a large amount of
	  physical memory, not all of it can be "permanently mapped" by the
	  kernel. The physical memory that's not permanently mapped is called
	  "high memory".

	  If you are compiling a kernel which will never run on a machine with
	  more than 1 Gigabyte total physical RAM, answer "off" here (default
	  choice and suitable for most users). This will result in a "3GB/1GB"
	  split: 3GB are mapped so that each process sees a 3GB virtual memory
	  space and the remaining part of the 4GB virtual memory space is used
	  by the kernel to permanently map as much physical memory as
	  possible.

	  If the machine has between 1 and 4 Gigabytes physical RAM, then
	  answer "4GB" here.

	  If more than 4 Gigabytes is used then answer "64GB" here. This
	  selection turns Intel PAE (Physical Address Extension) mode on.
	  PAE implements 3-level paging on IA32 processors. PAE is fully
	  supported by Linux, PAE mode is implemented on all recent Intel
	  processors (Pentium Pro and better). NOTE: If you say "64GB" here,
	  then the kernel will not boot on CPUs that don't support PAE!

	  The actual amount of total physical memory will either be
	  auto detected or can be forced by using a kernel command line option
	  such as "mem=256M". (Try "man bootparam" or see the documentation of
	  your boot loader (lilo or loadlin) about how to pass options to the
	  kernel at boot time.)

	  If unsure, say "off".

config HIGHMEM4G
	bool "4GB"
	---help---
	  Select this if you have a 32-bit processor and between 1 and 4
	  gigabytes of physical RAM.

config HIGHMEM64G
	bool "64GB"
	depends on !M486
	select X86_PAE
	---help---
	  Select this if you have a 32-bit processor and more than 4
	  gigabytes of physical RAM.

endchoice

choice
	prompt "Memory split" if EXPERT
	default VMSPLIT_3G
	depends on X86_32
	---help---
	  Select the desired split between kernel and user memory.

	  If the address range available to the kernel is less than the
	  physical memory installed, the remaining memory will be available
	  as "high memory". Accessing high memory is a little more costly
	  than low memory, as it needs to be mapped into the kernel first.
	  Note that increasing the kernel address space limits the range
	  available to user programs, making the address space there
	  tighter.  Selecting anything other than the default 3G/1G split
	  will also likely make your kernel incompatible with binary-only
	  kernel modules.

	  If you are not absolutely sure what you are doing, leave this
	  option alone!

	config VMSPLIT_3G
		bool "3G/1G user/kernel split"
	config VMSPLIT_3G_OPT
		depends on !X86_PAE
		bool "3G/1G user/kernel split (for full 1G low memory)"
	config VMSPLIT_2G
		bool "2G/2G user/kernel split"
	config VMSPLIT_2G_OPT
		depends on !X86_PAE
		bool "2G/2G user/kernel split (for full 2G low memory)"
	config VMSPLIT_1G
		bool "1G/3G user/kernel split"
endchoice

config PAGE_OFFSET
	hex
	default 0xB0000000 if VMSPLIT_3G_OPT
	default 0x80000000 if VMSPLIT_2G
	default 0x78000000 if VMSPLIT_2G_OPT
	default 0x40000000 if VMSPLIT_1G
	default 0xC0000000
	depends on X86_32

config HIGHMEM
	def_bool y
	depends on X86_32 && (HIGHMEM64G || HIGHMEM4G)

config X86_PAE
	bool "PAE (Physical Address Extension) Support"
	depends on X86_32 && !HIGHMEM4G
	---help---
	  PAE is required for NX support, and furthermore enables
	  larger swapspace support for non-overcommit purposes. It
	  has the cost of more pagetable lookup overhead, and also
	  consumes more pagetable space per process.

config HPET_TIMER
	def_bool X86_64
	prompt "HPET Timer Support" if X86_32
	---help---
	  Use the IA-PC HPET (High Precision Event Timer) to manage
	  time in preference to the PIT and RTC, if a HPET is
	  present.
	  HPET is the next generation timer replacing legacy 8254s.
	  The HPET provides a stable time base on SMP
	  systems, unlike the TSC, but it is more expensive to access,
	  as it is off-chip.  You can find the HPET spec at
	  <http://www.intel.com/hardwaredesign/hpetspec_1.pdf>.

	  You can safely choose Y here.  However, HPET will only be
	  activated if the platform and the BIOS support this feature.
	  Otherwise the 8254 will be used for timing services.

	  Choose N to continue using the legacy 8254 timer.

endmenu


#
# Misc configurations
#
menu	"Misc features"

config SPINLOCK_TICKET
	bool "Ticket Spinlock Implementation"
	---help---
	  This enables x86 spinlock implemented in tickets version. FIFO ticket
	  spinlock ensures fairness among different CPUS with negligible cost.
	  
	  If you say N here, the kernel will implement x86 spinlock in "dec" version,
	  which is implemented without any fairness guarentee. This is the default version.

	  If you don't know what to do here, say N.

endmenu


#
# Bus configurations
#
menu	"Bus options (PCI etc.)"

config PCI
	bool "PCI support"
	default y
	---help---
	  Find out whether you have a PCI motherboard. PCI is the name of a
	  bus system, i.e. the way the CPU talks to the other stuff inside
	  your box. Other bus systems are ISA, EISA, MicroChannel (MCA) or
	  VESA. If you have PCI, say Y, otherwise N.

choice
	prompt "PCI access mode"
	depends on X86_32 && PCI
	default PCI_GOANY
	---help---
	  On PCI systems, the BIOS can be used to detect the PCI devices and
	  determine their configuration. However, some old PCI motherboards
	  have BIOS bugs and may crash if this is done. Also, some embedded
	  PCI-based systems don't have any BIOS at all. Linux can also try to
	  detect the PCI hardware directly without using the BIOS.

	  With this option, you can specify how Linux should detect the
	  PCI devices. If you choose "BIOS", the BIOS will be used,
	  if you choose "Direct", the BIOS won't be used, and if you
	  choose "MMConfig", then PCI Express MMCONFIG will be used.
	  If you choose "Any", the kernel will try MMCONFIG, then the
	  direct access method and falls back to the BIOS if that doesn't
	  work. If unsure, go with the default, which is "Any".

config PCI_GOBIOS
	bool "BIOS"

config PCI_GOMMCONFIG
	bool "MMConfig"

config PCI_GODIRECT
	bool "Direct"

config PCI_GOOLPC
	bool "OLPC XO-1"
	depends on OLPC

config PCI_GOANY
	bool "Any"

endchoice

config PCI_BIOS
	def_bool y
	depends on X86_32 && PCI && (PCI_GOBIOS || PCI_GOANY)

# x86-64 doesn't support PCI BIOS access from long mode so always go direct.
config PCI_DIRECT
	def_bool y
	depends on PCI && (X86_64 || (PCI_GODIRECT || PCI_GOANY || PCI_GOOLPC || PCI_GOMMCONFIG))

endmenu
