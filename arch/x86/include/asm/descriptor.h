/*
 *	Copyright (C) 2015-2016 Yizhou Shan <shanyizhou@ict.ac.cn>
 *	
 *	This program is free software; you can redistribute it and/or modify
 *	it under the terms of the GNU General Public License as published by
 *	the Free Software Foundation; either version 2 of the License, or
 *	(at your option) any later version.
 *
 *	This program is distributed in the hope that it will be useful,
 *	but WITHOUT ANY WARRANTY; without even the implied warranty of
 *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *	GNU General Public License for more details.
 *
 *	You should have received a copy of the GNU General Public License along
 *	with this program; if not, write to the Free Software Foundation, Inc.,
 *	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

/*
 * This file describes x86 segment descriptors used in Sandix.
 *
 * A segment descriptor is a data structure in a GDT or LDT that
 * provides the processor with the size and location of a segment,
 * as well as access control and status information. See Intel
 * Software Developer Manual Volume 3, chapter 3.4.5 for details.
 */

#ifndef _ASM_X86_DESCRIPTOR_H_
#define _ASM_X86_DESCRIPTOR_H_

#include <sandix/bug.h>
#include <sandix/compiler.h>

#include <asm/segment.h>

/*
 * 8-byte segment descriptor
 */

struct desc_struct {
	union {
		struct {
			unsigned int a;
			unsigned int b;
		};
		struct {
			unsigned short limit0;
			unsigned short base0;
			unsigned base1:8, type:4, s:1, dpl:2, p:1;
			unsigned limit1:4, avl:1, l:1, d:1, g:1, base2:8;
		};
	};
} __packed;

typedef struct desc_struct gate_desc;
typedef struct desc_struct ldt_desc;
typedef struct desc_struct tss_desc;

struct desc_ptr {
	unsigned short size;
	unsigned long address;
} __packed;

extern struct desc_struct idt_table[];
extern struct desc_struct gdt_table[];

#define GDT_ENTRY_INIT(flags, base, limit)				\
{									\
	.a = ((limit) & 0xffff) | (((base) & 0xffff) << 16),		\
	.b = (((base) & 0xff0000) >> 16) | (((flags) & 0xf0ff) << 8) |	\
		((limit) & 0xf0000) | ((base) & 0xff000000),		\
}

static __always_inline void pack_gate(gate_desc *gate, unsigned char type,
				      unsigned long base, unsigned int dpl,
				      unsigned int flags, unsigned int seg)
{
	gate->a = ((base & 0xffff) << 16) | seg;
}

static inline int desc_empty(const void *ptr)
{
	const u32 *desc = ptr;

	return !(desc[0] | desc[1]);
}





/*
 * (1)
 * The processor check the DPL of the interrupt or trap gate
 * only if the interrupt or exception is generated by INT X.
 * The CPL must be less than or equal to the DPL of the gate.
 * For hardware-generated interrutps and processor-deteced
 * exceptions, the processor ignores the DPL of the gates.
 *
 * (2)
 * The only difference between trap and interrupt gates is the
 * way the processor handles the IF flags in EFLAGS register.
 *
 *  Through a trap gate, it does not affect the IF flag.
 *
 *  Through a interrupt gate, the processor clears the IF flag
 *  to prevent other interrupts from interfering with the current
 *  interrupt handler. A subsequent IRET instruction restores
 *  the IF flag to its value in the saved contents of the EFLAGS
 *  register on the stack. (The IF flag does not affect the
 *  generation of exceptions or NMI interrupts).
 */

#define __GATE_INTR	0xE
#define __GATE_TRAP	0xF

#define	__DPL_KERNEL	0
#define __DPL_USER	3

static inline void __set_gate(int gate, int addr, int type, int dpl, int ss)
{
	struct desc_struct desc;
	
	desc.a = (ss << 16) | (addr & 0xffff);
	desc.b = (addr & 0xffff0000) | 0x8000 | (dpl << 13) | (type <<8);

	idt_table[gate] = desc;
}

#define set_trap_gate(GATE, ADDR) \
	__set_gate(GATE, ADDR, __GATE_TRAP, __DPL_KERNEL, __KERNEL_CS);

#define set_intr_gate(GATE, ADDR) \
	__set_gate(GATE, ADDR, __GATE_INTR, __DPL_KERNEL, __KERNEL_CS);

#define set_system_call_gate(GATE, ADDR) \
	__set_gate(GATE, ADDR, __GATE_TRAP, __DPL_USER, __KERNEL_CS);


#endif /* _ASM_X86_DESCRIPTOR_H_*/
