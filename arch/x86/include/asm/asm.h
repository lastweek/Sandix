/*
 *	Copyright (C) 2015-2016 Yizhou Shan <shanyizhou@ict.ac.cn>
 *
 *	This program is free software; you can redistribute it and/or modify
 *	it under the terms of the GNU General Public License as published by
 *	the Free Software Foundation; either version 2 of the License, or
 *	(at your option) any later version.
 *
 *	This program is distributed in the hope that it will be useful,
 *	but WITHOUT ANY WARRANTY; without even the implied warranty of
 *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *	GNU General Public License for more details.
 *
 *	You should have received a copy of the GNU General Public License along
 *	with this program; if not, write to the Free Software Foundation, Inc.,
 *	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

/*
 * Wrappers for some special assembly instructions.
 */

#ifndef _ASM_X86_ASM_H_
#define _ASM_X86_ASM_H_

#include <asm/pgtable.h>

#define LOCK_PREFIX "lock; "

static inline void __cpuid(unsigned int *eax, unsigned int *ebx,
			   unsigned int *ecx, unsigned int *edx)
{
	/* ecx is often an input as well as an output. */
	asm volatile (
		"cpuid"
		: "=a" (*eax), "=b" (*ebx),
		  "=c" (*ecx), "=d" (*edx)
		: "0"  (*eax), "2"  (*ecx)
		: "memory"
	);
}

/*
 * Generic CPUID function
 * clear %ecx since some cpus (Cyrix MII) do not set or clear %ecx
 * resulting in stale register contents being returned.
 */
static inline void cpuid(unsigned int op,
			 unsigned int *eax, unsigned int *ebx,
			 unsigned int *ecx, unsigned int *edx)
{
	*eax = op;
	*ecx = 0;
	__cpuid(eax, ebx, ecx, edx);
}

/* Some CPUID calls want 'count' to be placed in ecx */
static inline void cpuid_count(unsigned int op, int count,
			       unsigned int *eax, unsigned int *ebx,
			       unsigned int *ecx, unsigned int *edx)
{
	*eax = op;
	*ecx = count;
	__cpuid(eax, ebx, ecx, edx);
}

/* CPUID calls that only return one result */
#define BUILD_CPUID_XXX(reg)					\
static inline unsigned int cpuid_##reg(unsigned int op)		\
{								\
	unsigned int eax, ebx, ecx, edx;			\
	cpuid(op, &eax, &ebx, &ecx, &edx);			\
	return reg;						\
}
BUILD_CPUID_XXX(eax)
BUILD_CPUID_XXX(ebx)
BUILD_CPUID_XXX(ecx)
BUILD_CPUID_XXX(edx)

#define nop()		asm volatile ("nop");
#define rep_nop()	asm volatile ("rep; nop" ::: "memory");
#define cpu_relax()	rep_nop()


static inline unsigned long read_cr0(void)
{
	unsigned long val;
	asm volatile (
		"mov %%cr0, %0"
		: "=r" (val)
		:
		: "memory"
	);
	return val;
}

static inline void write_cr0(unsigned long val)
{
	asm volatile (
		"mov %0, %%cr0"
		:
		: "r" (val)
		: "memory"
	);
}

static inline unsigned long read_cr3(void)
{
	unsigned long val;
	asm volatile (
		"mov %%cr3, %0"
		: "=r" (val)
		:
		: "memory"
	);
	return val;
}

static inline void write_cr3(unsigned long val)
{
	asm volatile (
		"mov %0, %%cr3"
		:
		: "r" (val)
		: "memory"
	);
}

static inline void load_cr3(pgd_t *pgdir)
{
	write_cr3(__pa(pgdir));
}

static inline void wbinvd(void)
{
	asm volatile ("wbinvb" : : : "memory");
}

static inline void clflush(volatile void *ptr)
{
	asm volatile ( "clflush %0" : "+m" (*(volatile char *)ptr));
}

/**
 * pcommit_sfence() - persistent commit and fence
 *
 * The PCOMMIT instruction ensures that data that has been flushed from the
 * processor's cache hierarchy with CLWB, CLFLUSHOPT or CLFLUSH is accepted to
 * memory and is durable on the DIMM.  The primary use case for this is
 * persistent memory.
 *
 * This function shows how to properly use CLWB/CLFLUSHOPT/CLFLUSH and PCOMMIT
 * with appropriate fencing.
 *
 * Example:
 * void flush_and_commit_buffer(void *vaddr, unsigned int size)
 * {
 *         unsigned long clflush_mask = boot_cpu_data.x86_clflush_size - 1;
 *         void *vend = vaddr + size;
 *         void *p;
 *
 *         for (p = (void *)((unsigned long)vaddr & ~clflush_mask);
 *              p < vend; p += boot_cpu_data.x86_clflush_size)
 *                 clwb(p);
 *
 *         // SFENCE to order CLWB/CLFLUSHOPT/CLFLUSH cache flushes
 *         // MFENCE via mb() also works
 *         wmb();
 *
 *         // PCOMMIT and the required SFENCE for ordering
 *         pcommit_sfence();
 * }
 *
 * After this function completes the data pointed to by 'vaddr' has been
 * accepted to memory and will be durable if the 'vaddr' points to persistent
 * memory.
 *
 * PCOMMIT must always be ordered by an MFENCE or SFENCE, so to help simplify
 * things we include both the PCOMMIT and the required SFENCE in the
 * alternatives generated by pcommit_sfence().
 */
static inline void pcommit_sfence(void)
{
/*
	alternative(ASM_NOP7,
		    ".byte 0x66, 0x0f, 0xae, 0xf8\n\t" // pcommit
		    "sfence",
		    X86_FEATURE_PCOMMIT);

*/
}

#endif /* _ASM_X86_ASM_H_ */
